# Script that can process the information downloaded from myLPG.eu via their
# route planner feature - see https://www.mylpg.eu/lpg-station-route-planner/

import argparse
import json
import logging
import re
from typing import Dict, List, Optional


# Get a logger to print messages.
logger = logging.getLogger(__name__)


def main():
    parser = argparse.ArgumentParser(
        description="Process data generated by myLPG.eu's route planner."
    )
    parser.add_argument("source", help="Path of the file to be processed")
    parser.add_argument("output", help="Output JSON file")
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Enable debug statements"
    )
    args = parser.parse_args()

    # Setup logging.
    logging.basicConfig(
        format="%(message)s", level=logging.DEBUG if args.verbose else logging.INFO
    )

    # Obtain information related to each fuel station.
    data = extract_station_data(args.source)

    # Save the extracted data into a JSON file.
    write_json(data, args.output)


def extract_station_data(file: str) -> List[Dict]:
    # Read the whole file.
    with open(file, "r", encoding="utf-8") as f:
        content = f.read()

    # Use a regex to split the content, using the string "n." as "identifier",
    # and discard the "header" (whatever comes before "1.").
    stations_txt = re.split(r"\n\d+\.\s+", content)[1:]

    # Process the blocks individually and give some feedback.
    processed_stations = list(map(process_station, stations_txt))
    stations = [s for s in processed_stations if s is not None]
    logger.info(
        f"Found {len(processed_stations)} stations, {len(stations)} of which were processed successfully."
    )
    return stations


def process_station(station_text: str) -> Optional[Dict]:
    """Process a block of text representing a single station.

    The expected format is the following (where "variables" are all wrapped in
    angular brackets for legibility):
    ```
    <Station name>
    <adress>
    <LPG-price> EUR/L (<date>)
    Distance on route from start: <x> km
    Airline distance from the route: <y> km
    Geographical latitude and longitude:
    (<lat>, <lon>)
    ```

    Note that the first line does not include the number of the station since it
    should've been stripped away during regex splitting.
    """
    # Remove empty spaces and lines.
    lines = [
        ln for ln in map(lambda s: s.strip(), station_text.strip().split("\n")) if ln
    ]

    # Due to how the file is formatted, we expect 7 lines of text.
    if len(lines) != 7:
        logging.debug(f"Skipping station ({len(lines)} lines, not 7)")
        return None

    # Extract the name and address, they should simply be the first and second
    # lines of text (I could process the address in a nicer way, but I do not
    # care too much right now).
    name = lines[0]
    address = lines[1]

    # Extract the price and the corresponding date.
    price_date_match = re.search(
        r"([0-9.]+)\s*EUR/L\s*\((\d{2}\.\d{2}\.\d{4})\)", lines[2]
    )

    if price_date_match is None:
        logging.debug(f"Skipping station (cannot extract price/date from '{lines[2]}')")
        return None

    price = float(price_date_match.group(1))
    price_date = price_date_match.group(2).replace(".", "/")

    # Finally, extract the GPS coordinates.
    coordinates_match = re.match(r"\(([-0-9.]+),\s*([-0-9.]+)\)", lines[6])

    if coordinates_match is None:
        logging.debug(
            f"Skipping station (cannot extract coordinates from '{lines[6]}')"
        )
        return None

    latitude = float(coordinates_match.group(1))
    longitude = float(coordinates_match.group(2))

    # Return a dictionary containing the extracted data.
    return {
        "name": name,
        "address-compact": address,
        "latitude": latitude,
        "longitude": longitude,
        "price": price,
        "price_date": price_date,
    }


def write_json(data, out_path):
    """Dump all data into a JSON file."""
    logger.info(f"Writing {len(data)} stations to JSON: {out_path}")
    with open(out_path, "w", encoding="utf-8") as file:
        json.dump(data, file, ensure_ascii=False)
    logger.info("Done.")


if __name__ == "__main__":
    main()
